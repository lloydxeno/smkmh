library(dynamite)
library(dplyr)

## Load male data
load("nlsy_males_long.RData")   # adjust filename if needed

## Within–between decomposition & lags (males)
lim_data_long_males <- lim_data_long_males %>%
  arrange(PUBID_1997, year) %>%
  group_by(PUBID_1997) %>%
  mutate(
    smkstat_lag = lag(smkstat, default = 0),
    mh5_lag     = lag(mh5,     default = 15),
    
    smkstat_bar = mean(smkstat, na.rm = TRUE),
    mh5_bar     = mean(mh5,     na.rm = TRUE),
    
    smkstat_lag_w = smkstat_lag - smkstat_bar,
    mh5_lag_w     = mh5_lag     - mh5_bar
  ) %>%
  ungroup()

## Same dynamite formula as for females
model_formula <- 
  # Smoking (Bernoulli)
  obs(
    smkstat ~ smkstat_lag_w + mh5_lag_w + smkstat_bar + mh5_bar +
      pct_peer_smk + age + random(~1),
    family = "bernoulli"
  ) +
  
  # Mental health (Gaussian)
  obs(
    mh5 ~ mh5_lag_w + smkstat_lag_w + smkstat_bar + mh5_bar +
      pct_peer_smk + age + random(~1),
    family = "gaussian"
  )

## Get default priors for the male data structure
required_priors_male <- get_priors(
  model_formula,
  data  = lim_data_long_males,
  time  = "year",
  group = "PUBID_1997"
)

p_male <- required_priors_male

## --------- Chaiton-based priors (males) ---------
## If you have sex-specific Chaiton ORs, replace 0.34 / 0.53 below
## with the male log(OR) values.

## Smoking (Bernoulli)
p_male$prior[p_male$parameter == "alpha_smkstat"]              <- "normal(-2, 1.0)"       # baseline smoking log-odds low
p_male$prior[p_male$parameter == "beta_smkstat_smkstat_lag_w"] <- "normal(1.0, 0.5)"      # strong persistence (within)
p_male$prior[p_male$parameter == "beta_smkstat_mh5_lag_w"]     <- "normal(0.34, 0.2)"     # depression → later smoking (Chaiton)
p_male$prior[p_male$parameter == "beta_smkstat_smkstat_bar"]   <- "normal(1.0, 0.5)"      # between-person persistence
p_male$prior[p_male$parameter == "beta_smkstat_mh5_bar"]       <- "normal(0.34, 0.2)"     # between-person depression effect
p_male$prior[p_male$parameter == "beta_smkstat_pct_peer_smk"]  <- "normal(0.10, 0.05)"    # peer smoking
p_male$prior[p_male$parameter == "beta_smkstat_age"]           <- "normal(0, 0.5)"
p_male$prior[p_male$parameter == "sigma_nu_smkstat_alpha"]     <- "normal(0, 1)"

## Mental health (Gaussian)
p_male$prior[p_male$parameter == "alpha_mh5"]                  <- "normal(15, 3)"         # around mean MH
p_male$prior[p_male$parameter == "beta_mh5_mh5_lag_w"]         <- "normal(0.6, 0.1)"      # strong autocorrelation
p_male$prior[p_male$parameter == "beta_mh5_smkstat_lag_w"]     <- "normal(0.53, 0.2)"     # smoking → later depression (Chaiton)
p_male$prior[p_male$parameter == "beta_mh5_mh5_bar"]           <- "normal(0.6, 0.1)"
p_male$prior[p_male$parameter == "beta_mh5_smkstat_bar"]       <- "normal(0.53, 0.2)"
p_male$prior[p_male$parameter == "beta_mh5_pct_peer_smk"]      <- "normal(0, 0.05)"
p_male$prior[p_male$parameter == "beta_mh5_age"]               <- "normal(0, 1.0)"
p_male$prior[p_male$parameter == "sigma_mh5"]                  <- "exponential(0.1)"

## Random effect correlation structure
p_male$prior[p_male$parameter == "L_nu"] <- "lkj_corr_cholesky(2)"

required_priors_male <- p_male

## Fit male model
smk_dep_males_fit <- dynamite(
  dformula          = model_formula,
  data              = lim_data_long_males,
  time              = "year",
  group             = "PUBID_1997",
  priors            = required_priors_male,
  chains            = 4,
  parallel_chains   = 4,
  threads_per_chain = 5,
  iter              = 4000,
  warmup            = 2000,
  refresh           = 100
)

save.image("male_model.RData")

#############################Post-estimation to Predict Distal Depression Outcome#################
load("~/Documents/NLSY/male_model.RData")
## ---- Packages ----
library(dplyr)
library(tidyr)
library(stringr)
library(haven)
library(posterior)
library(brms)

## ---- 0) Posterior draws from dynamite ----
draws_mat <- as_draws_matrix(smk_dep_males_fit$stanfit)

# Predictor sets used in both longitudinal equations
vars_mh5 <- c("mh5_lag_w","smkstat_lag_w","smkstat_bar","mh5_bar","pct_peer_smk","age")
vars_smk <- c("smkstat_lag_w","mh5_lag_w","smkstat_bar","mh5_bar","pct_peer_smk","age")

# Names of key parameters in draws_mat
col_alpha_mh5 <- "alpha_mh5"
col_alpha_smk <- "alpha_smkstat"
mh5_betas_all <- grep("^beta_mh5\\[",     colnames(draws_mat), value = TRUE)
smk_betas_all <- grep("^beta_smkstat\\[", colnames(draws_mat), value = TRUE)

## ---- 1) Read CES-D 2019 and merge into person-period dataset ----
cesd_2019 <- read_dta("cesd_2019.dta") %>%
  rename(cesd2019 = CV_CESD_SCORE_R19_2019) %>%
  select(PUBID_1997, cesd2019)

analysis_df <- inner_join(lim_data_long_males, cesd_2019, by = "PUBID_1997") %>%
  mutate(
    cesd2019_elevated = case_when(
      is.na(cesd2019) ~ NA_integer_,
      cesd2019 >= 16  ~ 1L,
      TRUE            ~ 0L
    )
  )

## ---- 2) Build person-level trajectories (mh5_pred, smk_pred) using posterior means ----
# Posterior means of dynamite parameters
summ <- summarise_draws(draws_mat, "mean")

alpha_mh5_hat <- summ$mean[summ$variable == col_alpha_mh5]
alpha_smk_hat <- summ$mean[summ$variable == col_alpha_smk]

beta_mh5_hat <- summ$mean[summ$variable %in% mh5_betas_all][1:length(vars_mh5)]
names(beta_mh5_hat) <- vars_mh5

beta_smk_hat <- summ$mean[summ$variable %in% smk_betas_all][1:length(vars_smk)]
names(beta_smk_hat) <- vars_smk

# Design matrices (person-period)
X_mh5 <- analysis_df %>%
  select(all_of(vars_mh5)) %>%
  mutate(across(everything(), as.numeric)) %>%
  as.matrix()

X_smk <- analysis_df %>%
  select(all_of(vars_smk)) %>%
  mutate(across(everything(), as.numeric)) %>%
  as.matrix()

# Person-period fitted values, then person-level trajectories
analysis_df <- analysis_df %>%
  mutate(
    mh5_pred_pp = as.numeric(alpha_mh5_hat + X_mh5 %*% beta_mh5_hat),
    smk_pred_pp = plogis(as.numeric(alpha_smk_hat + X_smk %*% beta_smk_hat))
  )

#collapse person-period to person level
analysis_person <- analysis_df %>%
  group_by(PUBID_1997) %>%
  summarise(
    cesd2019          = dplyr::first(cesd2019),
    cesd2019_elevated = dplyr::first(cesd2019_elevated),
    mh5_pred          = mean(mh5_pred_pp, na.rm = TRUE),
    smk_pred          = mean(smk_pred_pp, na.rm = TRUE),
    .groups = "drop"
  )

## ---- 3) Distal outcome model: elevated CES-D (logistic) ----
# Fit a logistic regression where each person contributes one observed outcome 
# (cesd2019_elevated) and two person-level predictors (mh5_pred, smk_pred).

bayes_model_2019 <- brm(
  cesd2019_elevated ~ mh5_pred + smk_pred,
  data = analysis_person,
  family = bernoulli(link = "logit"),
  prior = c(
    prior(normal(0, 2.5), class = "Intercept"),
    prior(normal(0, 2.5), class = "b")
  ),
  chains = 4, iter = 4000, warmup = 1000,
  seed = 1234, cores = 4
)

post_reg <- as_draws_matrix(bayes_model_2019)

## ---- 4) Counterfactual scenarios (based on person-period data) ----
# IMPORTANT: use the full person-period dataset here (analysis_df), not analysis_person.
scenario1 <- analysis_df %>% mutate(smkstat_bar = 1, smkstat_lag_w = 1)
scenario0 <- analysis_df %>% mutate(smkstat_bar = 0, smkstat_lag_w = 0)

# Compute person-level p(elevated) under one pair of (dynamite draw, logit draw)
compute_p <- function(df,
                      alpha_mh5_j, beta_mh5_vec_j,
                      alpha_smk_j, beta_smk_vec_j,
                      b_logit_j) {
  
  X_mh5 <- df[, names(beta_mh5_vec_j), drop = FALSE] %>%
    mutate(across(everything(), as.numeric)) %>% as.matrix()
  
  X_smk <- df[, names(beta_smk_vec_j), drop = FALSE] %>%
    mutate(across(everything(), as.numeric)) %>% as.matrix()
  
  mh5_pp <- as.numeric(alpha_mh5_j + X_mh5 %*% beta_mh5_vec_j)
  smk_pp <- plogis(as.numeric(alpha_smk_j + X_smk %*% beta_smk_vec_j))
  
  traj <- tibble::tibble(PUBID_1997 = df$PUBID_1997,
                         mh5_pp = mh5_pp,
                         smk_pp = smk_pp) %>%
    group_by(PUBID_1997) %>%
    summarise(
      mh5_pred = mean(mh5_pp, na.rm = TRUE),
      smk_pred = mean(smk_pp, na.rm = TRUE),
      .groups = "drop"
    )
  
  eta <- as.numeric(b_logit_j[1] + b_logit_j[2] * traj$mh5_pred + b_logit_j[3] * traj$smk_pred)
  traj$p_elev <- plogis(eta)
  traj
}

## ---- 5) Monte Carlo: marginal OR under (always smoke) vs (never smoke) ----
R <- 500L
set.seed(2025)

idx_dyn <- sample(seq_len(nrow(draws_mat)), size = R, replace = FALSE)
idx_reg <- sample(seq_len(nrow(post_reg)),  size = R, replace = TRUE)

OR_draws <- numeric(R)

for (r in seq_len(R)) {
  j <- idx_dyn[r]
  k <- idx_reg[r]
  
  alpha_mh5_j <- as.numeric(draws_mat[j, col_alpha_mh5])
  alpha_smk_j <- as.numeric(draws_mat[j, col_alpha_smk])
  
  n_mh5 <- min(length(mh5_betas_all), length(vars_mh5))
  n_smk <- min(length(smk_betas_all), length(vars_smk))
  
  beta_mh5_vec_j <- as.numeric(draws_mat[j, mh5_betas_all[1:n_mh5]])
  beta_smk_vec_j <- as.numeric(draws_mat[j, smk_betas_all[1:n_smk]])
  names(beta_mh5_vec_j) <- vars_mh5[1:n_mh5]
  names(beta_smk_vec_j) <- vars_smk[1:n_smk]
  
  b_logit_j <- c(
    as.numeric(post_reg[k, "b_Intercept"]),
    as.numeric(post_reg[k, "b_mh5_pred"]),
    as.numeric(post_reg[k, "b_smk_pred"])
  )
  
  p1_df <- compute_p(scenario1, alpha_mh5_j, beta_mh5_vec_j, alpha_smk_j, beta_smk_vec_j, b_logit_j)
  p0_df <- compute_p(scenario0, alpha_mh5_j, beta_mh5_vec_j, alpha_smk_j, beta_smk_vec_j, b_logit_j)
  
  cf <- inner_join(
    p1_df %>% select(PUBID_1997, p1 = p_elev),
    p0_df %>% select(PUBID_1997, p0 = p_elev),
    by = "PUBID_1997"
  )
  
  p1_bar <- mean(cf$p1, na.rm = TRUE)
  p0_bar <- mean(cf$p0, na.rm = TRUE)
  
  if (p1_bar <= 0 || p1_bar >= 1 || p0_bar <= 0 || p0_bar >= 1) {
    OR_draws[r] <- NA_real_
  } else {
    OR_draws[r] <- (p1_bar / (1 - p1_bar)) / (p0_bar / (1 - p0_bar))
  }
}

OR_draws <- OR_draws[is.finite(OR_draws) & !is.na(OR_draws)]
c(OR_median = median(OR_draws),
  OR_2.5    = unname(quantile(OR_draws, 0.025)),
  OR_97.5   = unname(quantile(OR_draws, 0.975)))

## ---- 6) Cleanup and save once ----
rm(smk_dep_males_fit, lim_data_long_males)  # keep analysis_df if you still need scenarios
gc()
save.image("~/Documents/NLSY/male_cesd_binary.RData")
####No need for Evalue analysis because credible interval for the OR spans 1.
